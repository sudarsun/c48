#ifndef _THRESHOLDCURVE_
#define _THRESHOLDCURVE_

#include <string>
#include <vector>
#include "core/Typedefs.h"

// Forward class declarations:
class TwoClassStats;
class Instances;
class Instance;
class Vector;
class Prediction;

/**
 * Generates points illustrating prediction tradeoffs that can be obtained by
 * varying the threshold value between classes. For example, the typical
 * threshold value of 0.5 means the predicted probability of "positive" must be
 * higher than 0.5 for the instance to be predicted as "positive". The resulting
 * dataset can be used to visualize precision/recall tradeoff, or for ROC curve
 * analysis (true positive rate vs false positive rate). Weka just varies the
 * threshold on the class probability estimates in each case. The Mann Whitney
 * statistic is used to calculate the AUC.
 *
 */
class ThresholdCurve {

public:
    /** The name of the relation used in threshold curve datasets */
    static const string RELATION_NAME;

    /** attribute name: True Positives  */
    static const string TRUE_POS_NAME;

    /** attribute name: False Negatives  */
    static const string FALSE_NEG_NAME;

    /** attribute name: False Positives  */
    static const string FALSE_POS_NAME;

    /** attribute name: True Negatives  */
    static const string TRUE_NEG_NAME;

    /** attribute name: False Positive Rate"  */
    static const string FP_RATE_NAME;

    /** attribute name: True Positive Rate  */
    static const string TP_RATE_NAME;

    /** attribute name: Precision  */
    static const string PRECISION_NAME;

    /** attribute name: Recall  */
    static const string RECALL_NAME;

    /** attribute name: Fallout  */
    static const string FALLOUT_NAME;

    /** attribute name: FMeasure  */
    static const string FMEASURE_NAME;

    /** attribute name: Sample Size  */
    static const string SAMPLE_SIZE_NAME;

    /** attribute name: Lift  */
    static const string LIFT_NAME;

    /** attribute name: Threshold  */
    static const string THRESHOLD_NAME;

    /**
     * Calculates the performance stats for the default class and return results
     * as a set of Instances. The structure of these Instances is as follows:
     * <p>
     * <ul>
     * <li><b>True Positives </b>
     * <li><b>False Negatives</b>
     * <li><b>False Positives</b>
     * <li><b>True Negatives</b>
     * <li><b>False Positive Rate</b>
     * <li><b>True Positive Rate</b>
     * <li><b>Precision</b>
     * <li><b>Recall</b>
     * <li><b>Fallout</b>
     * <li><b>Threshold</b> contains the probability threshold that gives rise to
     * the previous performance values.
     * </ul>
     * <p>
     * For the definitions of these measures, see TwoClassStats
     * <p>
     *
     * @see TwoClassStats
     * @param predictions the predictions to base the curve on
     * @return datapoints as a set of instances, null if no predictions have been
     *         made.
     */
    Instances *getCurve(std::vector<Prediction*> predictions);

    /**
    * Calculates the performance stats for the desired class and return results
    * as a set of Instances.
    *
    * @param predictions the predictions to base the curve on
    * @param classIndex index of the class of interest.
    * @return datapoints as a set of instances.
    */
    Instances *getCurve(std::vector<Prediction*> predictions, int classIndex);

    /**
     * Calculates the n point precision result, which is the precision averaged
     * over n evenly spaced (w.r.t recall) samples of the curve.
     *
     * @param tcurve a previously extracted threshold curve Instances.
     * @param n the number of points to average over.
     * @return the n-point precision.
     */
    static double getNPointPrecision(Instances *tcurve, const int n);

    /**
     * Calculates the area under the ROC curve as the Wilcoxon-Mann-Whitney
     * statistic.
     *
     * @param tcurve a previously extracted threshold curve Instances.
     * @return the ROC area, or Double.NaN if you don't pass in a ThresholdCurve
     *         generated Instances.
     */
    static double getROCArea(Instances *tcurve);

    /**
    * Gets the index of the instance with the closest threshold value to the
    * desired target
    *
    * @param tcurve a set of instances that have been generated by this class
    * @param threshold the target threshold
    * @return the index of the instance that has threshold closest to the target,
    *         or -1 if this could not be found (i.e. no data, or bad threshold
    *         target)
    */
    static int getThresholdInstance(Instances *tcurve, const double threshold);

private:
    /**
    * performs a binary search
    *
    * @param index the indices
    * @param vals the values
    * @param target the target to look for
    * @return the index of the target
    */
    static int binarySearch(const int_array &index, const double_array &vals, const double target);

    /**
     * Get probabilities on the prediction
     * @param predictions the predictions to use
     * @param classIndex the class index
     * @return the probabilities
     */
    double_array getProbabilities(std::vector<Prediction*> predictions, const int classIndex) const;

    /**
     * generates the header
     *
     * @return the header
     */
    Instances *makeHeader();

    /**
    * generates an instance out of the given data
    *
    * @param tc the statistics
    * @param prob the probability
    * @return the generated instance
    */
    Instance *makeInstance(TwoClassStats *tc, const double prob);

};


#endif    //#ifndef _THRESHOLDCURVE_
